<h1 align="center">
  <br>
  <a><img src="https://github.com/khandelwal-arpit/ironclad/blob/main/docs/images/logo.jpeg" alt="ironclad"></a>
  <br>
  Starter-kit for Web applications using RUST
  <br>
</h1>

<h4 align="center">Production ready Starter-kit for RUST based web applications.</h4>

<p align="center">
    <a alt="Rust">
        <img src="https://img.shields.io/badge/Rust-v1.72.0-orange.svg" />
    </a>
    <a alt="Actix">
        <img src="https://img.shields.io/badge/Actix%20Web-v4-brightgreen.svg" />
    </a>
    <a alt="Diesel">
        <img src="https://img.shields.io/badge/Diesel-v2.0.0-yellowgreen.svg">
    </a>
    <a alt="r2d2">
        <img src="https://img.shields.io/badge/r2d2-PGSQL-orange.svg">  
    </a>      
    <a alt="Docker">
        <img src="https://img.shields.io/badge/Docker-v24-yellowgreen.svg" />
    </a>
    <a alt="Dependencies">
        <img src="https://img.shields.io/badge/dependencies-up%20to%20date-brightgreen.svg" />
    </a>
    <a alt="Contributions">
        <img src="https://img.shields.io/badge/contributions-welcome-orange.svg" />
    </a>
    <a alt="License">
        <img src="https://img.shields.io/badge/license-MIT-blue.svg" />
    </a>
</p>

# IRONCLAD
QLDB (Quantum Ledger Database) written in RUST, tailored for Banking/Financial institutions.

The main aim behind creating this RUST application was to setup a boilerplate application showing how to use RUST for REST API use cases. We have used the following tools/crates while creating this codebase-

- **Actix** - Server side framework
- **Diesel** - ORM
- **r2d2** - Connection pool manager 
- **PostgreSQL** - SQL database 
- **utoipa** - Autogenerated OpenAPI documentation for Rust REST APIs
- **Docker** - Containerizing framework
- **Rapidoc** - API documentation

# Business Requirements
Creating a detailed requirement specification for your blockchain-based banking platform is a crucial step in the development process. Below, I've broken down your high-level requirements into more detailed specifications:

### 1. User Registration and Account Creation
- Users can register on the platform using unique email addresses.
- Upon successful registration, a user account is created.

### 2. Transaction Types
- Users can perform the following transactions:
  - User registration (Initial transaction).
  - Deposit: Add funds to their account.
  - Withdraw: Remove funds from their account.
  - Transfer: Send funds from their account to another user's account.
  - Account_Close: Close the account of a user.

### 3. Transaction Hashes
- Each transaction submitted to the system must have a unique hash generated and stored with it.
- The hash is used for verification and ensuring data integrity.

### 4. Block Mining
- Blocks are mined at regular intervals.
- When a block is mined, it contains a sequence of transactions, including their hashes.
- Transactions within a block are processed sequentially on a first-come, first-served basis.
- Before execution, transactions are verified using their corresponding hashes.

### 5. Block Hashes
- Each block must have a unique hash associated with it.
- The block hash should be generated when all transactions within the block are finalized.
- The block hash should ideally be a combination of transaction hashes within the block.

### 6. Event Generation
- After a block is mined and transactions are executed, events must be generated for each transaction.
- Events should denote whether the transaction was successful or resulted in failure.


## Onion Architecture
Onion architecture is a software design pattern that organizes the codebase into concentric layers, with the core layer containing the most fundamental and independent code, and the outer layers containing more specific and dependent code. This separation of concerns makes the codebase more maintainable and scalable, as each layer can be changed without affecting the other layers.

Actix web is a popular web framework for Rust that is well-suited for implementing the application layer of the onion architecture. It is built on top of the Actix actor framework, which provides a clear separation of concerns and modularity. Actix web is also high-performance and scalable, making it a good choice for building web applications of all sizes.

In simpler terms, onion architecture is a way of organizing your code so that it is easier to maintain and update. Actix web is a web framework that can be used to implement onion architecture in Rust.

Here is an analogy:

Imagine a cake with multiple layers. Each layer has a different flavor and texture, but they all work together to create a delicious cake. The onion architecture is similar to a cake in that each layer is independent of the other layers. This means that you can change the flavor or texture of one layer without affecting the other layers.

Actix web is like the frosting on the cake. It provides a layer of functionality that makes it easy to build web applications. However, Actix web is not necessary for onion architecture. You can use any web framework you want to implement onion architecture.

## IRONCLAD Architecture Overview
The onion architecture is a layered architecture that is based on the onion model. 
Where each layer in the onion model is used to define the different layers of an application.

For this rust implementation 4 layers are used:
* api (app) module: The outermost layer that contains the controllers and the endpoints definition, serialization and deserialization of the data, validation and error handling.
* infrastructure: Layer that typically include database connections, external APIs calls, logging and configuration management.
* services: Layer that contains the application's services, which encapsulate the core business logic and provide a higher-level abstraction for the application to interact with the domain entities.
* domain: The innermost layer that contains the core business logic and entities of the application.


Folder structure:
```
.
├── migrations
├── scripts
│   └── run_postgres.sh # Run postgres in docker locally
├── src
│   ├── api
│   │   ├── controllers
│   │   │   └── ...  # controllers for the api
│   │   ├── dto # Data transfer objects  
│   │   │   └── ... # Individual DTOs
│   │   └── errors.py
│   ├── infrastructure
│   │   ├── services
│   │   │   └── ...  # Services that use third party libraries or services (e.g. email service)
│   │   ├── databases
│   │   │   └── ...  # Database adapters and initialization
│   │   ├── repositories
│   │   │   └── ...  # Repositories for interacting with the databases
│   │   └── models
│   │       └── ...  # Database models
│   ├── domain
│   │   ├── mod.rs
│   │   ├── constants.rs
│   │   ├── errors.rs
│   │   ├── models
│   │   │   └── ...  # Business logic models traits or structs
│   │   ├── services
│   │   │   └── ...  # Service traits
│   │   └── repositories
│   │       └── ...  # Repository traits 
│   ├── services
│   │   └── ...  # Concrete service implementation for interacting with the domain (business logic)
│   ├── container.rs
│   ├── create_app.rs # app factory 
│   ├── lib.rs 
│   └── main.rs
```

* migrations: Ironclad's migration scripts are stored here.
* scripts: contains the application's useful scripts.


## How to setup the application locally?

1. Take a git pull on your local machine
2. Ensure a postgreSQL instance is running locally/remotely
3. Rename .env.sample to .env
3. Set DATABASE_URL env variable in the .env file
4. Set MAX_DB_SESSIONS_PER_WORKER to a realistic number (1/2/3 should be fine for local usage)
7. Run 'cargo watch -x run' to run with hot reloading enabled or simply 'cargo run'
8. To run tests, fire `cargo test` command

## Commands

# Start local PG Instance v14 on macos
``` bash
docker-compose up -d
```
# Diesel migrations

Migrations will be run automatically on application run or test run, but below are steps to run them manually as well:

```
diesel setup
diesel migration generate <migration_name>
diesel migration run
```

Command to create a new migration script-
```
diesel migration generate <migration_name>
```

If you want to reset the database and rerun the migrations, use the following command-
```
diesel database reset
```

# Launch server
Use the watch command if hot reloading is desired
```
cargo watch -x run
cargo run
```

# Launch test cases
To launch the test cases with a clean database use the following command-
```
sh scripts/test.sh
```

## Application URLs

### Backend URL
http://localhost:8080/api

### Rapidoc URL
http://localhost:8080/rapidoc

<img src="https://github.com/khandelwal-arpit/ironclad/blob/main/docs/images/rapidoc.png" alt="rapidoc"></a>

## License
This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.